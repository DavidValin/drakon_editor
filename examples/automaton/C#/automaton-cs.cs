// Autogenerated with DRAKON Editor 1.25
using System;
using System.Collections.Generic;
using System.Text;

namespace AutomatonTest {

public enum TokenType
{
	None,
	Identifier,
	Number,
	Operator
}

internal class LexerData
{
	public readonly StringBuilder Buffer = new StringBuilder();
	public readonly List<Token> Tokens = new List<Token>();
}

public class Token
{
	public readonly String Text;
	public readonly TokenType Type;
	public Token(string text, TokenType type)
	{
		Text = text;
		Type = type;
	}
	public override string ToString()
	{
		return String.Format("{0} {1}", Text, Type);
	}
}

public class Lexer {


	private static readonly List<string> LongOperators = new List<string>
		{ "==", "<=", ">=", "!=", "&&", "||" };
	private static readonly bool[] OperatorChars = new bool[255];
	
	

    public partial class LexerMachine {
        
        // Currently built token and list of tokens.
        private readonly LexerData Data = new LexerData();
        
        // The output list of tokens.
        public List<Token> Tokens { get { return Data.Tokens; } }
        public enum StateNames {
            Invalid,
            Idle,
            Identifier,
            Number,
            Operator
        }
        private StateNames CurrentState = StateNames.Idle;

        public void Digit(char c) {
            switch (CurrentState) {
                case StateNames.Idle:
                    Idle_Digit(c);
                    break;
                case StateNames.Identifier:
                    Identifier_Digit(c);
                    break;
                case StateNames.Number:
                    Number_Digit(c);
                    break;
                case StateNames.Operator:
                    Operator_Digit(c);
                    break;
                case StateNames.Invalid:
                    throw new System.InvalidOperationException(
                        "Actor was in Invalid state. Message: Digit");
            }
        }

        public void Letter(char c) {
            switch (CurrentState) {
                case StateNames.Idle:
                    Idle_Letter(c);
                    break;
                case StateNames.Identifier:
                    Identifier_Letter(c);
                    break;
                case StateNames.Number:
                    Number_Letter(c);
                    break;
                case StateNames.Operator:
                    Operator_Letter(c);
                    break;
                case StateNames.Invalid:
                    throw new System.InvalidOperationException(
                        "Actor was in Invalid state. Message: Letter");
            }
        }

        public void Operator(char c) {
            switch (CurrentState) {
                case StateNames.Idle:
                    Idle_Operator(c);
                    break;
                case StateNames.Identifier:
                    Identifier_Operator(c);
                    break;
                case StateNames.Number:
                    Number_Operator(c);
                    break;
                case StateNames.Operator:
                    Operator_Operator(c);
                    break;
                case StateNames.Invalid:
                    throw new System.InvalidOperationException(
                        "Actor was in Invalid state. Message: Operator");
            }
        }

        public void Whitespace(char c) {
            switch (CurrentState) {
                case StateNames.Idle:
                    Idle_Whitespace(c);
                    break;
                case StateNames.Identifier:
                    Identifier_Whitespace(c);
                    break;
                case StateNames.Number:
                    Number_Whitespace(c);
                    break;
                case StateNames.Operator:
                    Operator_Whitespace(c);
                    break;
                case StateNames.Invalid:
                    throw new System.InvalidOperationException(
                        "Actor was in Invalid state. Message: Whitespace");
            }
        }

        public void dummy(char c) {
            switch (CurrentState) {
                case StateNames.Idle:
                    break;
                case StateNames.Identifier:
                    break;
                case StateNames.Number:
                    Number_dummy(c);
                    break;
                case StateNames.Operator:
                    break;
                case StateNames.Invalid:
                    throw new System.InvalidOperationException(
                        "Actor was in Invalid state. Message: dummy");
            }
        }

        private void Idle_Whitespace(char c) {
            // item 23
            CurrentState = StateNames.Idle;
        }

        private void Idle_Letter(char c) {
            // item 44
            AddChar(Data, c);
            // item 47
            CurrentState = StateNames.Identifier;
        }

        private void Idle_Digit(char c) {
            // item 45
            AddChar(Data, c);
            // item 48
            CurrentState = StateNames.Number;
        }

        private void Idle_Operator(char c) {
            // item 46
            AddChar(Data, c);
            // item 49
            CurrentState = StateNames.Operator;
        }

        private void Identifier_Whitespace(char c) {
            // item 65
            CreateIdentifier(Data);
            // item 31
            CurrentState = StateNames.Idle;
        }

        private void Identifier_Letter(char c) {
            // item 59
            AddChar(Data, c);
            // item 62
            CurrentState = StateNames.Identifier;
        }

        private void Identifier_Digit(char c) {
            // item 60
            AddChar(Data, c);
            // item 63
            CurrentState = StateNames.Identifier;
        }

        private void Identifier_Operator(char c) {
            // item 66
            CreateIdentifier(Data);
            // item 61
            AddChar(Data, c);
            // item 64
            CurrentState = StateNames.Operator;
        }

        private void Number_Whitespace(char c) {
            // item 82
            CreateNumber(Data);
            // item 34
            CurrentState = StateNames.Idle;
        }

        private void Number_Letter(char c) {
            // item 76
            AddChar(Data, c);
            // item 79
            CurrentState = StateNames.Number;
        }

        private void Number_Digit(char c) {
            // item 77
            AddChar(Data, c);
            // item 80
            CurrentState = StateNames.Number;
        }

        private void Number_Operator(char c) {
            // item 83
            CreateNumber(Data);
            // item 78
            AddChar(Data, c);
            // item 81
            CurrentState = StateNames.Operator;
        }

        private void Number_dummy(char c) {
            // item 81
            CurrentState = StateNames.Operator;
        }

        private void Operator_Whitespace(char c) {
            // item 99
            CreateOperator(Data);
            // item 26
            CurrentState = StateNames.Idle;
        }

        private void Operator_Letter(char c) {
            // item 100
            CreateOperator(Data);
            // item 93
            AddChar(Data, c);
            // item 96
            CurrentState = StateNames.Identifier;
        }

        private void Operator_Digit(char c) {
            // item 101
            CreateOperator(Data);
            // item 94
            AddChar(Data, c);
            // item 97
            CurrentState = StateNames.Number;
        }

        private void Operator_Operator(char c) {
            // item 103
            if (TryMakeLongOperator(Data, c)) {
                // item 106
                CurrentState = StateNames.Idle;
            } else {
                // item 107
                CreateOperator(Data);
                // item 95
                AddChar(Data, c);
                // item 98
                CurrentState = StateNames.Operator;
            }
        }
    }

    public static List<Token> Lex(string text) {
        IEnumerator<char> _it168 = null;
        char c = default(char);
        // item 167
        Init();
        var lexer = new LexerMachine();
        // item 1680001
        _it168 = ((IEnumerable<char>)text).GetEnumerator();
        while (true) {
            // item 1680002
            if (_it168.MoveNext()) {
                
            } else {
                break;
            }
            // item 1680004
            c = _it168.Current;
            // item 172
            if (c == '_') {
                // item 181
                lexer.Letter(c);
            } else {
                // item 175
                if (Char.IsLetter(c)) {
                    // item 181
                    lexer.Letter(c);
                } else {
                    // item 178
                    if (Char.IsDigit(c)) {
                        // item 182
                        lexer.Digit(c);
                    } else {
                        // item 183
                        if (IsOperator(c)) {
                            // item 186
                            lexer.Operator(c);
                        } else {
                            // item 187
                            lexer.Whitespace(' ');
                        }
                    }
                }
            }
        }
        // item 171
        lexer.Whitespace(' ');
        // item 170
        return lexer.Tokens;
    }

    public static void Main() {
        IEnumerator<Token> _it204 = null;
        Token token = default(Token);
        // item 161
        string text = "foo.Bar(34 / 4-(18+m * 3));";
        List<Token> tokens = Lex(text);
        // item 207
        Console.WriteLine("Text:\n{0}", text);
        Console.WriteLine("Tokens:");
        // item 2040001
        _it204 = ((IEnumerable<Token>)tokens).GetEnumerator();
        while (true) {
            // item 2040002
            if (_it204.MoveNext()) {
                
            } else {
                break;
            }
            // item 2040004
            token = _it204.Current;
            // item 206
            Console.WriteLine(token);
        }
    }

    private static void AddChar(LexerData data, char c) {
        // item 120
        data.Buffer.Append(c);
    }

    private static void CreateIdentifier(LexerData data) {
        // item 126
        CreateToken(data, TokenType.Identifier);
    }

    private static void CreateNumber(LexerData data) {
        // item 142
        CreateToken(data, TokenType.Number);
    }

    private static void CreateOperator(LexerData data) {
        // item 148
        CreateToken(data, TokenType.Operator);
    }

    private static void CreateToken(LexerData data, TokenType type) {
        // item 132
        if (data.Buffer.Length == 0) {
            
        } else {
            // item 135
            string text = data.Buffer.ToString();
            data.Buffer.Length = 0;
            // item 136
            Token token = new Token(text, type);
            data.Tokens.Add(token);
        }
    }

    private static void Init() {
        // item 203
        OperatorChars['!'] = true;
        OperatorChars['='] = true;
        OperatorChars['<'] = true;
        OperatorChars['>'] = true;
        OperatorChars['-'] = true;
        OperatorChars['+'] = true;
        OperatorChars['/'] = true;
        OperatorChars['\\'] = true;
        OperatorChars['*'] = true;
        OperatorChars['%'] = true;
        OperatorChars['('] = true;
        OperatorChars[')'] = true;
        OperatorChars['['] = true;
        OperatorChars[']'] = true;
        OperatorChars['{'] = true;
        OperatorChars['}'] = true;
        OperatorChars[':'] = true;
        OperatorChars['.'] = true;
        OperatorChars[';'] = true;
        OperatorChars[','] = true;
        OperatorChars['^'] = true;
        OperatorChars['|'] = true;
        OperatorChars['&'] = true;
        OperatorChars['"'] = true;
        OperatorChars['\''] = true;
    }

    private static bool IsOperator(char c) {
        // item 194
        if (c >= OperatorChars.Length) {
            // item 197
            return false;
        } else {
            // item 193
            return OperatorChars[c];
        }
    }

    private static bool TryMakeLongOperator(LexerData data, char c) {
        // item 154
        char previous = data.Buffer[0];
        char[] chars = { previous, c };
        string text = new String(chars);
        // item 155
        if (LongOperators.Contains(text)) {
            // item 158
            data.Buffer.Length = 0;
            Token token = new Token(text, TokenType.Operator);
            data.Tokens.Add(token);
            // item 159
            return true;
        } else {
            // item 160
            return false;
        }
    }
}
}
